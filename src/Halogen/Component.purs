-- | This module defines a type of composable _components_, built from
-- | the types provided by this library - signal functions and HTML documents.

module Halogen.Component
  ( Component()

  , combine
  , hoistComponent
  ) where

import Data.DOM.Simple.Types

import Data.Int
import Data.Maybe
import Data.Either

import Control.Monad.Eff

import Halogen.HTML (HTML())
import Halogen.Signal (SF1(), mergeWith)

-- | A component.
-- |
-- | The type parameters are, in order:
-- |
-- | - `m`, the monad used to track effects required by external requests
-- | - `req`, the type of external requests
-- | - `res`, the type of external responses
-- |
-- | Request and response types are public, but the component may also use an _internal_ type
-- | of messages, as illustrated by the type of the `component` function.
-- |
-- | The main interface to Halogen is the `runUI` function, which takes a component as an argument,
-- | with certain constraints between the type arguments. This module leaves the type arguments
-- | unrestricted, allowing components to be composed in various ways.
-- |
-- | If you do not use a particular feature (e.g. requests, responses, effects), you might like to leave
-- | the corresponding type parameter unconstrained in the declaration of your component.
type Component p m req res = SF1 req (HTML p (m res))

-- | Map a natural transformation over the monad type argument of a `Component`.
-- |
-- | This function may be useful during testing, to mock requests with a different monad.
hoistComponent :: forall p m n req res. (forall a. m a -> n a) -> Component p m req res -> Component p n req res
hoistComponent f sf = (f <$>) <$> sf

-- | Combine two components into a single component.
-- |
-- | The first argument is a function which combines the two rendered HTML documents into a single document.
-- |
-- | This function works on request and response types by taking the _sum_ in each component. The left summand
-- | gets dispatched to (resp. is generated by) the first component, and the right summand to the second component.
combine :: forall p m req1 req2 res1 res2.
             (Functor m) =>
             (forall a. HTML p a -> HTML p a -> HTML p a) ->
             Component p m req1 res1 ->
             Component p m req2 res2 ->
             Component p m (Either req1 req2) (Either res1 res2)
combine f = mergeWith f1
  where
  f1 :: HTML p (m res1) -> HTML p (m res2) -> HTML p (m (Either res1 res2))
  f1 n1 n2 = f ((Left <$>) <$> n1) ((Right <$>) <$> n2)
